/*
 * nokia5110.c
 *
 *  Created on: 22/07/2016
 *      Author: rikardonm
 */

#include "nokia5110.hpp"


static const uint8_t char_table[][5] =
{
 {0x00, 0x00, 0x00, 0x00, 0x00} // 20
,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
,{0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c ï¿½
,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j
,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e <-
,{0x78, 0x46, 0x41, 0x46, 0x78} // 7f ->
};


enum ModuleBaseCommandCodes : uint8_t
{
    FunctionSet = 0x20,
};

enum ModuleH0CommandCodes : uint8_t
{
    DisplayControl = 0x08,
    SetYAdddress = 0x40,
    SetXAddress = 0x80,
};

enum ModuleH1CommandCodes : uint8_t
{
    TemperatureControl = 0x04,
    BiasSystem = 0x10,
    Vop = 0x80,
};


// static const uint8_t init_sequence[] = {
//     0x21,   // function set -> H = 1
//     0xB4,   // Vop
//     0x04,   // Temp Coef
//     0x14,   // Bias bs2
//     0x20,   // function set -> H = 0
//     0x0C    // display control -> D = 1
// };






Nokia5110::Nokia5110(SPIClass spi, Pin ssn, Pin data_commandn, Pin reset)
: spi(spi), ssn(ssn), resetn(reset), data_commandn(data_commandn), initd(false)
{
}


void Nokia5110::Init()
{
    if (initd)
    {
        return;
    }

    /* Configure HW layer */
    spi.begin();
    /* SET CLOCK HERE !!!!!!!! */
    /* FIXME */
    ssn.Configure(false);
    ssn.Set(true);
    data_commandn.Configure(false);
    data_commandn.Set(false);
    resetn.Configure(true);
    resetn.Set(false);

    /* Configure logical layer */

    // for(tempc = 0; tempc < 0xFFF; tempc++);
    delay(1);

    /* Steps as defined in Section 13, Table 6 of PCD8544 LCD controller datasheet
        https://www.sparkfun.com/datasheets/LCD/Monochrome/Nokia5110.pdf
    */

    uint8_t init_sequence[5];
    init_sequence[0] = FunctionSet(PowerDownControl::Active, AddressingMode::Horizontal, InstructionSetChoice::Extended);
    init_sequence[1] = Vop(0x4F);
    init_sequence[2] = FunctionSet(PowerDownControl::Active, AddressingMode::Horizontal, InstructionSetChoice::Basic);
    init_sequence[3] = DisplayControl(DisplayModes::AllSegmentsOn);
    init_sequence[4] = BiasSystem(4);

    Raw(init_sequence, sizeof(init_sequence), true);

    uint8_t test_sequence[7] = {
        0x1F,
        0x05,
        0x07,
        0x00,
        0x1F,
        0x30,
        0x1F
    };
    Raw(test_sequence, sizeof(init_sequence), false);

    /* nokia init */
    // for(auto x : init_sequence)
    // {
    //     Cmd(x);
    //     delayMicroseconds(5);
    // }
    // for(tempc = 0; tempc < sizeof(nokiaInitSequence); tempc++)
    // {
    // 	Cmd(nokiaInitSequence[tempc]);
    // 	for(tempc2 = 0; tempc2 < 0xFF; tempc2++);
    // }


    // for(uint32_t tempc = 0; tempc < (48 * 84 / 8); ++tempc)
    // {
    //     //clear lcd
    //     Raw(0x00);
    // }

    // Pos(0, 0);
    // String("Hello world!");

    // Pos(0, 1);
    // String("Second line!");

    // char tempstr[32];
    // Pos(0, 2);
    // String("f=");
    // Pos(3, 2);
    // myitoa(80, tempstr);
    // String(tempstr);
    // Pos(6, 2);
    // String("kHz");

    initd = true;
}

void Nokia5110::Char(char mychar)
{
    uint8_t tosend[6];
    const uint8_t* base_ptr = char_table[mychar - 0x20];

    tosend[0] = base_ptr[0];
    tosend[1] = base_ptr[1];
    tosend[2] = base_ptr[2];
    tosend[3] = base_ptr[3];
    tosend[4] = base_ptr[4];

    /* add space */
    tosend[5] = 0x00;

    // 5 is for current font length
    Raw(tosend, 5, false);
}

void Nokia5110::String(const char* src)
{
    while(*src)
    {
        Char(*src);
        src++;
    }
}

void Nokia5110::Pos(uint8_t x, uint8_t y)
{
    uint8_t position[2];
    position[0] = SetXAddress(x);
    position[1] = SetYAddress(y);
    Raw(position, 2, true);
}

constexpr uint8_t Nokia5110::FunctionSet(PowerDownControl power_down, AddressingMode entry_mode, InstructionSetChoice instruction_set)
{
    return ModuleBaseCommandCodes::FunctionSet | power_down | entry_mode | instruction_set;
}

constexpr uint8_t Nokia5110::DisplayControl(DisplayModes mode)
{
    return ModuleH0CommandCodes::DisplayControl | mode;
}

constexpr uint8_t Nokia5110::SetYAddress(uint8_t value)
{
    if (value > 5)
    {
        value = 5;
    }
    return ModuleH0CommandCodes::SetYAdddress | value;
}

constexpr uint8_t Nokia5110::SetXAddress(uint8_t value)
{
    if (value > 83)
    {
        value = 83;
    }
    return ModuleH0CommandCodes::SetXAddress | value;
}

constexpr uint8_t Nokia5110::TemperatureControl(uint8_t value)
{
    return ModuleH1CommandCodes::TemperatureControl | (value & 0x03);
}

constexpr uint8_t Nokia5110::BiasSystem(uint8_t value)
{
    return ModuleH1CommandCodes::BiasSystem | (value & 0x07);
}

constexpr uint8_t Nokia5110::Vop(uint8_t value)
{
    return ModuleH1CommandCodes::Vop | (value & 0x7F);
}


void Nokia5110::Cmd(uint8_t data)
{
    data_commandn.Set(false);
    ssn.Set(false);
    spi.transfer(data);
    ssn.Set(true);
}

void Nokia5110::Raw(uint8_t data)
{
    data_commandn.Set(true);
    ssn.Set(false);
    spi.transfer(data);
    ssn.Set(true);
}

void Nokia5110::Raw(const uint8_t* data, size_t len, bool is_command)
{
    data_commandn.Set(!is_command);
    delayMicroseconds(1);
    ssn.Set(false);
    delayMicroseconds(1);
    for (int i = 0; i < len; ++i)
    {
        spi.transfer(data[i], SPITransferMode::SPI_CONTINUE);
    }
    delay(1);
    ssn.Set(true);
}








/* reverse:  reverse string s in place */
void reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s) - 1; i < j; i++, j--)
    {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}

/* itoa:  convert n to characters in s */
void myitoa(unsigned int n, char s[])
{
    int i;
    i = 0;
    do
    /* generate digits in reverse order */
    {
        s[i++] = n % 10 + '0';   /* get next digit */
    } while ((n /= 10) > 0);     /* delete it */

    s[i] = '\0';
    reverse(s);
}



